---
title: "Deskriptive Statistik"
author: "Tutorial von [_Professor Bernd Heesen_](http://www.prescient.pro), dem Autor des Buches [_Data Science und Statistik mit R_](https://www.amazon.de/Data-Science-Statistik-mit-Anwendungsl%C3%B6sungen/dp/3658348240/ref=sr_1_1?__mk_de_DE=%C3%85M%C3%85%C5%BD%C3%95%C3%91&dchild=1&keywords=Data+Science+und+Statistik+mit+R&qid=1627898747&sr=8-1)"
date: "23.10.2021"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(tidyverse)
library(learnr)
library(forcats)
library(gridExtra)
```


## Willkommen

Dieses Tutorial erg√§nzt die Inhalte des Buches [_Data Science und Statistik mit R_](https://www.amazon.de/Data-Science-Statistik-mit-Anwendungsl%C3%B6sungen/dp/3658348240/ref=sr_1_1?__mk_de_DE=%C3%85M%C3%85%C5%BD%C3%95%C3%91&dchild=1&keywords=Data+Science+und+Statistik+mit+R&qid=1627898747&sr=8-1).

Das Kapitel 4.1 im Buch behandelt die Deskriptive Statistik. Nachfolgend wird vorgestellt, wie die Deskriptive Statistik von R unterst√ºtzt wird.

```{r x_y-setup, exercise.setup="x_y", exercise=FALSE, echo=FALSE, include=FALSE}

```

Berechnen Sie ....

Die Anzeige sollte hinterher wie folgt aussehen: ![Vektor](images/xxx.jpg)

```{r x_y, exercise=TRUE}

```

```{r x_y-hint-1}

```
```{r x_y-hint-2}

```

## 1. Statistik

In der Statistik werden in der Regel quantitative und qualitative Daten analysiert, um neues Wissen zu erlangen. Mit Hilfe der Statistik versucht man Fragen zu beantworten wie z.B. was ist der g√ºnstigste Preis f√ºr ein Produkt, um einen maximalen Profit zu erzielen. Um eine solche Frage zu beantworten, ben√∂tigt man zun√§chst Daten. Diese Daten liegen entweder bereits vollst√§ndig vor oder man versucht diese selbst zu erheben, z.B. durch Beobachtungen, Umfragen, Experimente oder andere Methoden.

Leider ist es oft schwer oder unm√∂glich alle relevanten Daten zu einer vollst√§ndigen Population, der gesamten Gruppe aller betrachteten Objekte, zu sammeln. Einerseits ist es sehr zeitaufw√§ndig und andererseits zu teuer oder schlicht unm√∂glich z.B. als Eink√§ufer den besten Preis f√ºr ein Produkt zu finden, da es sehr viele Webseiten gibt und dar√ºber hinaus viele Gesch√§fte weltweit, wo das Produkt gekauft werden kann. Es ist oft unm√∂glich alle Daten zusammenzutragen, denn w√§hrend man gerade noch Daten erfasst, √§ndern sich die Preise andernorts bereits wieder bei dem einen oder anderen H√§ndler, dessen Daten man bereits erfasst hat. 

Insofern ist man als Forscher oft gezwungen mit einer Stichprobe oder Teilmenge der Population zu arbeiten. Wichtig ist dabei, dass eine Stichprobe m√∂glichst repr√§sentativ f√ºr die Population ist, will man doch oft von den Erkenntnissen der Stichprobe auf die Population schlie√üen k√∂nnen. Das Ziel Daten einer Stichprobe zu untersuchen ist in der Regel, dass man aus diesen Daten auf die Population schlie√üen m√∂chte. Dies bezeichnet man auch als Inferenz und wird im Rahmen der Inferenzstatistik oder induktiven Statistik behandelt.

Die deskriptive Statistik und Wissen √ºber die Daten einer Stichprobe bilden die Grundlage f√ºr die induktive Statistik. Die Daten zu beschreiben ist Aufgabe der deskriptiven Statistik.

Statistik: ![Statistik](images/statistik.jpg)

### 1.1 Deskriptive Statistik

Die deskriptive Statistik unterscheidet bei den Daten zwischen sogenannten Lagema√üen (Ma√üzahlen der zentralen Tendenz) und Streuungsma√üen (Ma√üzahlen der Verteilung) (siehe Abb. 4-2 im Buch). Lagema√üe sind u.a. der Modus, Median und Mittelwert. Streuungsma√üe sind u.a. Spannweite, Abweichung, Varianz und Standardabweichung.

Nicht alle Lagema√üe und Streuungsma√üe lassen sich f√ºr jede Variable ermitteln. Daher ist es von Bedeutung zun√§chst die unterschiedlichen Variablentypen zu differenzieren: Kategoriale oder auch qualitative Variablen und kardinale, metrische, numerische oder quantitative Variablen (siehe Abb. 4-3 im Buch).

Die qualitativen Variablen lassen sich in nominale Variablen ohne Rangordnung (bin√§re Variable: Sonderfall mit zwei Auspr√§gungen) und ordinale Variablen mit Rangordnung unterscheiden. Beispiele f√ºr qualitative Variablen sind:

Nominal
‚Ä¢	Familienstatus: Verheiratet, geschieden, Single
‚Ä¢	Zahlungsmodus: Bar, √úberweisung, Kreditkarte
‚Ä¢	Logik: Wahr, falsch
‚Ä¢	Geschlecht: Mann, Frau

Ordinal
‚Ä¢	Einkommen: Niedrig, mittel, hoch
‚Ä¢	Zufriedenheit: Sehr gut, gut, mittel, schlecht, sehr schlecht
‚Ä¢	Zustimmungsgrad: Stimme stark zu, stimme zu, neutral, stimme nicht zu, stimme gar nicht zu
‚Ä¢	Wahrnehmung: Sehr kalt, kalt, normal, hei√ü, sehr hei√ü

Die quantitativen Variablen lassen sich unterscheiden in Intervallvariablen, die keinen nat√ºrlichen Nullpunkt besitzen und daher auch keine Verh√§ltnisaussagen erm√∂glichen und Verh√§ltnisvariablen, die einen nat√ºrlichen Nullpunkt besitzen und daher Verh√§ltnisaussagen erm√∂glichen. Beispiele f√ºr quantitative Variablen sind:

Intervall
‚Ä¢	Temperatur in Grad Celsius
‚Ä¢	Jahr

Verh√§ltnis
‚Ä¢	Preis
‚Ä¢	Alter
‚Ä¢	Gewicht

Folgende Auswertungen der deskriptiven Statistik lassen sich auf die unterschiedlichen Variablentypen anwenden.

Statistische Auswertungen je Variablentyp: ![Auswertungen](images/auswertungen.jpg)

### 1.2 Lagema√üe

Das arithmetische Mittel, auch Mittelwert oder Durchschnitt genannt, ist das wichtigste Ma√ü der zentralen Tendenz. Um diesen Wert zu berechnen, summiert man zun√§chst alle Einzelwerte und teilt diese dann durch die Anzahl der Einzelwerte (siehe Abb. 4-5 im Buch). Der Mittelwert ist eine wertvolle Ma√üzahl, kann jedoch durch sogenannte Ausrei√üer, extrem niedrige oder hohe Werte, stark beeinflusst werden. In R kann die Funktion mean() zur Berechnung des Mittelwerts verwendet werden.

Extreme Einzelwerte k√∂nnen den Mittelwert signifikant beeinflussen. Daher verwendet man neben dem Mittelwert eine weitere Ma√üzahl, die durch extreme Werte nicht beeinflusst ist, den Median. Der Median wird bestimmt, indem man alle Einzelwerte zun√§chst aufsteigend sortiert. Bei einer ungeraden Anzahl von Werten ist der Median der Einzelwert, der in der Mitte liegt. Bei einer geraden Anzahl von Werten berechnet sich der Median aus dem Mittelwert der beiden Einzelwerte in der Mitte. In R l√§sst sich die Funktion median() nutzen, um den Median zu ermitteln.

Eine weiteres Lagema√ü ist der Modus, der Wert, der am h√§ufigsten vorkommt. Man kann den Modus ermitteln, indem man z√§hlt, wie h√§ufig jeder der Werte vorkommt. Der Wert, der am h√§ufigsten vorkommt, ist der Modus. Ein Nachteil des Modus als Lagema√ü der zentralen Tendenz ist, dass er nicht in der Mitte der Werte liegen muss. Daher betrachtet man in der Regel den Mittelwert, den Median und den Modus gemeinsam, um eine Vorstellung √ºber die Verteilung einer Variablen zu erhalten. In R existiert keine spezielle Funktion f√ºr die Berechnung des Modus. Die Funktion table() kann aber hilfreich sein, denn sie gibt die H√§ufigkeit des Vorkommens der Werte in tabellarischer Form an. F√ºr numerische Variablen kann alternativ auch die Funktion stem() verwendet werden, die ein sogenanntes Stem-and-leaf-Plot anzeigt. Ein Stem-and-leaf-Plot organisiert numerische Daten entsprechend ihren Dezimalwerten. Die linke Spalte zeigt den sogenannten Stamm an, also alle Ziffern der Dezimalzahl au√üer der letzten Ziffer. Die sogenannten Bl√§tter in der rechten Spalte repr√§sentieren die letzte Ziffer der Dezimalzahl und jede Zahl dort repr√§sentiert einen Datensatz.

```{r 1_1, exercise=FALSE}
head(studierende,3)
sp1 <- as_tibble(studierende[1:15,5])                  # Stichprobe 1 (sp1)
colnames(sp1) <- "Gr√∂√üe"
sp2 <- as_tibble(studierende[70:85,5])                 # Stichprobe 2 (sp2)
colnames(sp2) <- "Gr√∂√üe"
sp1$sp <- "Stichprobe 1"
sp2$sp <- "Stichprobe 2"
sp1und2 <- rbind(sp1,sp2)                              # Daten beider Stichproben
#- Lagema√ü: Mittelwert------------------------------------------------------------
sp1$Gr√∂√üe                                              # Gr√∂√üe anzeigen sp1
mean(sp1$Gr√∂√üe)                                        # Mittelwert sp1
sp2$Gr√∂√üe                                              # Gr√∂√üe anzeigen sp2
sp2.mean <- mean(sp2$Gr√∂√üe)                            # Mittelwert sp2
sp2.mean
#- Lagema√ü: Median----------------------------------------------------------------
sort(sp1$Gr√∂√üe)                                        # Gr√∂√üe sortiert sp1
median(sp1$Gr√∂√üe)                                      # Median sp1
sort(sp2$Gr√∂√üe)                                        # Gr√∂√üe sortiert sp2
sp2.median <- median(sp2$Gr√∂√üe)                        # Median sp2
sp2.median
#- Lagema√ü: Modus-----------------------------------------------------------------
table(sp1$Gr√∂√üe)                                       # Verteilung sp1
stem(sp1$Gr√∂√üe)                                        # Stem-Plot sp1
g <- as.data.frame(table(sp1$Gr√∂√üe))                   # table() -> Dataframe
filter(g, Freq == max(g$Freq))$Var1                    # Modus sp1
table(sp2$Gr√∂√üe)                                       # Verteilung sp2
stem(sp2$Gr√∂√üe)                                        # Stem-Plot sp2
h <- as.data.frame(table(sp2$Gr√∂√üe))                   # table() -> Dataframe
sp2.modus <- filter(h, Freq == max(h$Freq))$Var1       # Modus sp2
sp2.modus <- as.numeric(as.character(sp2.modus))       # Konvertierung numerisch
sp2.modus                                              # Ausgabe
```

### 1.3 Streuungsma√üe

W√§hrend Lagema√üe die mittleren Werte einer Datenmenge beschreiben, beschreiben Streuungsma√üe wie weit die Werte verteilt bzw. gestreut sind und wie weit sie von den mittleren Werten entfernt sind. Nur Lagema√üe zu betrachten ist oft nicht ausreichend, da Stichproben mit dem gleichen Mittelwert oder Median eine sehr unterschiedliche Streuung haben k√∂nnen.

Mittelwert ungeeignet als Streuungsma√ü: ![Mittelwert](images/mittelwert.jpg)

Nur Streuungsma√üe zu betrachten ist ebenso wenig ausreichend, um ein Verst√§ndnis der Daten zu erlangen.

Um die Streuung besser zu verstehen, dienen u.a. die Ma√ügr√∂√üen der Spannweite und des Interquartilsabstands. Die Spannweite beschreibt die Distanz zwischen dem gr√∂√üten und dem kleinsten Wert. Im Beispiel von Abb. 4-7 im Buch betr√§gt die Spannweite 351 ‚Äì 12 = 339. In R gibt es keine Standardfunktion f√ºr die Berechnung der Spannweite. Die Funktion range() ist aber hilfreich, da sie den kleinsten und gr√∂√üten Wert anzeigt. Die Spannweite f√ºr die Variable x kann dann mit der Anweisung max(range(x, na.rm = TRUE)) - min(range(x, na.rm = TRUE)) ermittelt werden. Noch geschickter ist die Anweisung max(x) ‚Äì min(x).

```{r 1_2, exercise=FALSE}
plot(sp2$Gr√∂√üe,rep(1,nrow(sp2)),ylab="Stichprobe 2",main="Scatterplot", # Plot sp2
     yaxt="n",xlab="K√∂rpergr√∂√üe in cm",xlim=c(150,210))
abline(v=min(sp2$Gr√∂√üe),col="red",lwd=2)               # Minimun: rot
abline(v=max(sp2$Gr√∂√üe),col="red",lwd=2)               # Maximum: rot
abline(v=mean(sp2$Gr√∂√üe), col="blue", lwd=4)           # Mittelwert: blau
abline(v=median(sp2$Gr√∂√üe), col="dark green", lwd=1)   # Median: gr√ºn
abline(v=modus, col="orange", lwd=1)                   # Modus: orange          
range(sp2$Gr√∂√üe, na.rm = TRUE)                         # Range sp2
max(sp2$Gr√∂√üe)                                         # Maximum sp2
min(sp2$Gr√∂√üe)                                         # Minimum sp2
max(sp2$Gr√∂√üe)- min(sp2$Gr√∂√üe)                         # Spannweite sp2
```

### 1.3.1 Quantile, Quartile und Interquartilsabstand

Den Median stellt den Wert dar, der in der Mitte liegt. Der Median wird auch das 2. Quartil bzw. das 50% Quantil genannt. Quantilswerte sind Lagema√üe und geben die H√∂he des Wertes an, f√ºr den gilt, dass ein gewisser Prozentsatz aller Werte niedriger ist. Das 50%-Quantil gibt den Wert an, f√ºr den gilt, dass 50% aller Werte kleiner als dieser sind. Insofern stellt das 0%-Quantil den kleinsten Wert, das 100%-Quantil den gr√∂√üten Wert dar. Das 25%-Quantil wird auch als 1. Quartil (Quartil, da die Menge in vier Teilbereiche mit je 25% aufgeteilt wird) bezeichnet, das 50%-Quantil als 2. Quartil oder Median und das 75%-Quantil als 3. Quartil. Die Funktion quantile() berechnet in R die Quartile und das Minimum und Maximum. Es existieren unterschiedliche Formeln f√ºr die Berechnung der Quantile in R. Die auch von SPSS und Minitab verwendete Formel kann in R √ºber den Parameter type=6 verwendet werden, z.B. quantile(anzahl,type=6). Wenn der Parameter nicht angegeben wird, so verwendet R als Standard type=7 als Berechnungsgrundlage. Details zu den unterschiedlichen Berechnungsformeln ist in der Hilfe zur Funktion nachlesbar, die mit der Anweisung ?quantile aufgerufen werden kann.

Der Abstand zwischen dem 1. und dem 3. Quartil wird auch als Interquartilsabstand (englisch: Interquartilerange, IQR) bezeichnet und gibt neben der Spannweite die Streuung der mittleren 50% aller Werte an. Um den IQR zu ermitteln, kann in R die Funktion IQR() ebenfalls mit dem Parameter type=6 verwendet werden.

Angenommen es existiert ein Vektor mit dem Namen anzahl, der die folgenden Werte 351, 120, 12, 30, 121, 63, 57, 91, 97, 100, 102 beinhaltet. Um herausfinden, wie gro√ü die Zahl in dem Vektor anzahl sein muss, wenn 70% aller Werte kleiner sein sollen bzw. die Zahl zu den gr√∂√üten 30% geh√∂ren soll, kann folgende Anweisung quantile(anzahl, probs=0.70) verwendet werden und ergibt als Ergebnis den Wert 109,2.

Eine Zusammenfassung wesentlicher Ma√üzahlen liefert auch die Funktion summary(). Sie verwendet den type=7 f√ºr die Berechnung und gibt Minimum, Maximum, 1. bis 3. Quartil, Mittelwert und ggfs. die Anzahl fehlender Werte aus.

```{r 1_3, exercise=FALSE}
anzahl <- c(351,120,12,30,121,63,57,91,97,100,102)     # Numerische Variable
quantile(anzahl,type=6)                                # Quantile
quantile(anzahl,type=6, probs=0.25)                    # 25%-Quantil, 1. Quartil
quantile(anzahl,type=6, probs=0.70)                    # 70%-Quantil
quantile(anzahl,type=7, probs=0.70)                    # 70%-Quantil
IQR(anzahl,type=6)                                     # Interquartilsabstand
quantile(anzahl)                                       # Quantile
summary(anzahl)                                        # Zusammenfassung
quantile(sp2$Gr√∂√üe,type=6)                             # Quantile Gr√∂√üe
```

### 1.3.2 Box-Plot

Die Quartile und der Interquartilsabstand werden besonders gut in einem Box-Plot sichtbar, denn in einem Box-Plot werden folgende Werte abgebildet: Minimum, Erstes Quartil (Q1), Median (Q2), Drittes Quartil (Q3) und Maximum. Ein Box-Plot stellt eine Box dar und Antennen (Whiskers) oben und unten. Die H√∂he der Box stellt den Interquartilsabstand dar, der untere Rand der Box das Erste Quartil (Q1) und der obere Rand der Box das Dritte Quartil (Q3). Umso gr√∂√üer die Box ist, umso gr√∂√üer ist die Streuung, welche durch den Interquartilsabstand gemessen wird. Die sogenannten Antennen (Whiskers) oder gestrichelten Linien unterhalb und oberhalb der Box erg√§nzt um die Ausrei√üer (Outliers), die als Kreise dargestellt werden, beschreiben die niedrigsten 25% und h√∂chsten 25% aller Werte. Um einen Box-Plot anzuzeigen existiert die Funktion boxplot(), die im Standard die Antennen mit einer L√§nge von 1,5 * IQR (Interquartilsabstand) darstellt. Werte, die mehr als 1,5 * IQR von dem Q1 nach unten oder von dem Q3 nach oben abweichen, werden als Ausrei√üer dargestellt. M√∂chte man Ausrei√üer nicht angezeigt bekommen und stattdessen die Antennen von Q1 bis Minimum und von Q3 bis Maximum angezeigt bekommen, so ist dies mit dem Parameter range=0 m√∂glich.

```{r 1_4, exercise=FALSE}
boxplot(Gr√∂√üe~sp,data=sp1und2,main="Boxplot",xlab="",  # Boxplot mit Ausrei√üern
        ylab="K√∂rpergr√∂√üe in cm")
boxplot(Gr√∂√üe~sp,data=sp1und2,main="Boxplot",xlab="",  # Boxplot ohne Ausrei√üer
        ylab="K√∂rpergr√∂√üe in cm",range=0)
```

### 1.3.3 Summe der Abweichungsquadrate, Varianz und Standardabweichung

Eine weitere bedeutende Ma√ügr√∂√üe f√ºr die Streuung ist die Varianz. Mathematisch berechnet sich die Varianz als der Durchschnitt der Abweichungsquadrate (Quadrat der Abweichungen aller Werte vom Mittelwert (siehe Abb. 4-8 im Buch). 

Die einfache Summierung aller Abweichungen vom Mittelwert ist ungen√ºgend, da die Abweichungen positive und negative Werte annehmen k√∂nnen, die sich gegenseitig ausgleichen, auch wenn die Abweichungen gro√ü sind. Ein kleiner Wert dieser Summe w√§re daher nicht aussagekr√§ftig. Auch die Summe der Quadrate der Abweichungen (Sum of Squared Errors, SS) w√§re keine gute Ma√ügr√∂√üe der Abweichung, denn bei zunehmender Anzahl an Werten w√ºrde die Ma√üzahl zunehmen, obwohl die durchschnittliche Abweichung nicht h√∂her ausf√§llt. F√ºr eine Population wird die Varianz ùúé2 (Sigma Quadrat) daher berechnet als die Summe der Abweichungsquadrate (SS) geteilt durch die Anzahl der Beobachtungen (N = Gr√∂√üe der Population, wenn die gesamte Population beobachtet wurde). Die Stichprobenvarianz s¬≤ dagegen ergibt sich als Summe der Abweichungsquadrate (SS) geteilt durch die Anzahl der Freiheitsgrade (Freiheitsgrad = n ‚Äì 1, n = Anzahl der Beobachtungen der Stichprobe).

```{r 1_5, exercise=FALSE}
sp1 <- arrange(sp1, sp1$Gr√∂√üe)                         # Tibble sp1 sortieren
sp1meanGr√∂√üe <- mean(sp1$Gr√∂√üe)                        # Mittelwert sp1
sp1$no <- rep(1:nrow(sp1))                             # Spalte f√ºr Nummer
sp1 <- mutate(sp1, diffGr√∂√üe = Gr√∂√üe - sp1meanGr√∂√üe)   # Spalte f√ºr Differenz
sp2 <- arrange(sp2, sp2$Gr√∂√üe)                         # Tibble sp2 sortieren
sp2meanGr√∂√üe <- mean(sp2$Gr√∂√üe)                        # Mittelwert sp2
sp2$no <- rep(1:nrow(sp2))                             # Spalte f√ºr Nummer
sp2 <- mutate(sp2, diffGr√∂√üe = Gr√∂√üe - sp2meanGr√∂√üe)   # Spalte f√ºr Differenz
p1 <- ggplot(sp1, aes(no, Gr√∂√üe)) +                    # Verteilung sp1
  geom_abline(intercept = sp1meanGr√∂√üe, slope = 0, colour = "red") +
  geom_point(colour = "blue") +
  geom_linerange(aes(ymin = sp1meanGr√∂√üe, ymax = Gr√∂√üe), colour = "grey40") +
  ylim(150,210) + labs(title="Stichprobe 1", x="",y="K√∂rpergr√∂√üe in cm")
p2 <- ggplot(sp2, aes(no, Gr√∂√üe)) +                    # Verteilung sp2
  geom_abline(intercept = sp2meanGr√∂√üe, slope = 0, colour = "red") +
  geom_point(colour = "dark green") +
  geom_linerange(aes(ymin = sp2meanGr√∂√üe, ymax = Gr√∂√üe), colour = "grey40") +
  ylim(150,210) + labs(title="Stichprobe 2", x="",y="K√∂rpergr√∂√üe in cm")
grid.arrange(p1, p2, ncol = 2)                         # Grafik p1+p2 ausgeben
tab <- select(sp1, Gr√∂√üe, diffGr√∂√üe)                   # Tibble tab anlegen
colnames(tab) <- c("Gr√∂√üe","Abweichung")               # Spaltennamen festlegen
tab$AbwQuadrat <- tab$Abweichung^2                     # Abweichungsquadrat
tab                                                    # Ausgabe
round(sum(tab$Abweichung),2)                           # Summe der Abweichungen
round(sum(tab$AbwQuadrat),2)                           # Summe Abweichungsquadrate
```

In R dient die Funktion var() zur Berechnung der Varianz und diese berechnet im Standard die Stichprobenvarianz s¬≤, teilt also durch n-1. Zur Berechnung der Varianz der Population ùúé2 (Sigma Quadrat) kann bei Bedarf die folgende Funktion definiert werden: sigmaquadrat <- function(x) {n=length(x); var(x, na.rm=T) * (n-1)/n}.

```{r 1_6, exercise=FALSE}
round(sum(tab$AbwQuadrat)/(nrow(tab)-1),2)       # Stichprobenvarianz
round(sum(tab$AbwQuadrat)/(nrow(tab)),2)         # Varianz der Population
round(var(tab$Gr√∂√üe),2)                          # Stichprobenvarianz
sigmaquadrat <- function(x)                      # Funktion f√ºr die Berechnung
  {n=length(x); var(x, na.rm=T) * (n-1)/n}       # der Varianz der Population
round(sigmaquadrat(tab$Gr√∂√üe),2)                 # Varianz der Population
```

Die Varianz hat den Nachteil, dass sie auf den quadrierten Abweichungen basiert und damit unrealistisch erh√∂ht ist. Daher zieht man die Wurzel aus der Varianz, um die Standardabweichung der Population ùúé (Sigma) bzw. die Standardabweichung der Stichprobe s zu ermitteln. In R kann die Funktion sd() (Standard Deviation) verwendet werden, um die Standardabweichung der Stichprobe s zu berechnen. Zur Berechnung der Standardabweichung der Population ùúé (Sigma) kann bei Bedarf die folgende Funktion definiert werden: sigma <- function(x) {n=length(x); sqrt(var(x, na.rm=T) * (n-1)/n)}.

Die Standardabweichung ist eine sehr aussagekr√§ftige Ma√ügr√∂√üe der Statistik.

```{r 1_7, exercise=FALSE}
round(sqrt(sum(tab$AbwQuadrat)/(nrow(tab)-1)),2) # Standardabweichung Stichprobe
round(sd(tab$Gr√∂√üe),2)                           # Standardabweichung Stichprobe
sigma <- function(x)                             # Funktion f√ºr die Berechnung
  {n=length(x); sqrt(var(x, na.rm=T) * (n-1)/n)} # der Standardabw. der Population
round(sigma(tab$Gr√∂√üe),2)                        # Standardabweichung Population
sd(sp1$Gr√∂√üe)                                    # Standardabweichung Stichprobe 1
sd(sp2$Gr√∂√üe)                                    # Standardabweichung Stichprobe 2
```

### 1.4 √úbung

```{r 1_8-setup, exercise.setup="1_8", exercise=FALSE, echo=FALSE, include=FALSE}

```

Der Vektor i wurde durch die Anweisung c(3, -10, -20, 40) und der Dataframe df mit der Anweisung data.frame(x= c(53,2,100), y=c(299,20,30)) angelegt. Erstellen Sie eine logische Operation auf den Vektor i, welche pr√ºft, ob f√ºr die Elemente gilt, dass der Inhalt des Elements multipliziert mit 5 ein Ergebnis produziert, welches gr√∂√üer als 20 ist. Erstellen Sie dar√ºber hinaus eine logische Operation die pr√ºft, ob y-x aus dem Dataframe df eine positive Zahl ergibt.

Die Anzeige sollte hinterher wie folgt aussehen: ![LogischeOperation](images/logischeoperation.jpg)

```{r 1_8, exercise=TRUE}

```

```{r 1_8-hint-1}
i*5>20
```
```{r 1_8-hint-2}
with(df,y-x>0)   # ODER
df$y-df$x>0
```


## 2. Logische Operationen

Auch logische Operationen lassen sich auf verschiedene Objekte anwenden.
Logische Operationen: ![Logische Operationen](images/logischeoperationen.jpg)

Neben einer einfachen logischen Operation l√§sst sich auch ein logisches ODER (Symbol f√ºr Disjunktion in R: |), logisches UND (Symbol f√ºr Konjunktion in R: &) und die logische NEGATION (Symbol f√ºr Negation in R: !) in Bedingungen einsetzen.

### 2.1 Einfache logische Operationen

```{r 2_1, exercise=FALSE}
a <- 48                               # numerische Variable
a                                     # Ausgabe
a == 48                               # Operator == mit Ergebnis TRUE
a == 84                               # Operator == mit Ergebnis FALSE
a != 84                               # Operator != mit Ergebnis TRUE
a < 84                                # Operator < mit Ergebnis TRUE
a <= 84                               # Operator <= mit Ergebnis TRUE
a > 84                                # Operator > mit Ergebnis FALSE
a >= 84                               # Operator >= mit Ergebnis FALSE
class(a)                              # Datentyp
is.numeric(a)                         # Datentyp is.numeric TRUE
! is.numeric(a)                       # Datentyp ! is.numeric FALSE
is.numeric(a) & a > 84                # Datentyp is.numeric AND a>84 FALSE
is.numeric(a) | a > 84                # Datentyp is.numeric OR a>84 TRUE
```

### 2.2 Logische Operationen auf Vektoren

```{r 2_2-setup, exercise.setup="2_2", exercise=FALSE, echo=FALSE, include=FALSE}
i <- c(3, -10, -20, 40)               # vektor numerisch L√§nge 4
df <- data.frame(x= c(53,2,100), y=c(299,20,30)) # Dataframe
```

Wenn R eine logische Operation auf einem Vektor ausf√ºhrt, so wird diese f√ºr jedes Element des Vektors einzeln ausgef√ºhrt und ein Ergebnis produziert, das so viele logische Werte erzeugt, wie Elemente in dem Vektor existieren. Die einzelnen Werte stellen bei TRUE dar, dass ein Element die Bedingung erf√ºllt und bei FALSE, dass die Bedingung f√ºr dieses Element nicht erf√ºllt ist.

```{r 2_2, exercise=TRUE}
i                                     # Ausgabe
truefalse1 <- i > 0                   # Operator > auf Vektor
truefalse1                            # Ausgabe
df                                    # Ausgabe
truefalse2 <- df > 50                 # Operator > auf Dataframe
truefalse2                            # Ausgabe
```

### 2.3 √úbung

```{r 2_3-setup, exercise.setup="2_3", exercise=FALSE, echo=FALSE, include=FALSE}
i <- c(3, -10, -20, 40)                          # vektor numerisch L√§nge 4
df <- data.frame(x= c(53,2,100), y=c(299,20,30)) # Dataframe
```

Der Vektor i wurde durch die Anweisung c(3, -10, -20, 40) und der Dataframe df mit der Anweisung data.frame(x= c(53,2,100), y=c(299,20,30)) angelegt. Erstellen Sie eine logische Operation auf den Vektor i, welche pr√ºft, ob f√ºr die Elemente gilt, dass der Inhalt des Elements multipliziert mit 5 ein Ergebnis produziert, welches gr√∂√üer als 20 ist. Erstellen Sie dar√ºber hinaus eine logische Operation die pr√ºft, ob y-x aus dem Dataframe df eine positive Zahl ergibt.

Die Anzeige sollte hinterher wie folgt aussehen: ![LogischeOperation](images/logischeoperation.jpg)

```{r 2_3, exercise=TRUE}

```

```{r 2_3-hint-1}
i*5>20
```
```{r 2_3-hint-2}
with(df,y-x>0)   # ODER
df$y-df$x>0
```

## 3. Selektive Operationen

Mit Hilfe selektiver Operationen ist es m√∂glich Elemente aus Vektoren, Dataframes und anderen Datenstrukturen auszuw√§hlen.

### 3.1 Einfache Selektive Operationen

Der Vektor mit dem Alter der Teammitglieder, der mit der Anweisung alter <- sample(c(floor(runif(16, min=0, max=100)), rep(NA, 4))) angelegt werden kann, enth√§lt offensichtlich 20 numerische Elemente mit positiven Zahlen zwischen 0 und 100 Jahren oder der Angabe NA f√ºr einen fehlenden Wert, wenn die befragte Person ihr Alter nicht angegeben hat. Die Funktion rep() erzeugt wiederholt ein Element (1. Parameter) n Mal (2. Parameter). Ebenso kann ein logischer Vektor truefalse mit 20 Elementen durch die Anweisung truefalse <- rep(c(TRUE, FALSE),10) erzeugt werden, der abwechselnd ein TRUE und FALSE enth√§lt.

Die Funktion alter[truefalse] zeigt dann nur die Elemente an, bei denen im Vektor truefalse der Wert TRUE steht. So kann mit Hilfe von TRUE und FALSE eine Selektion erfolgen.

```{r 3_1, exercise=FALSE}
alter <- sample(c(floor(runif(16,min=0,max=100)),rep(NA,4))) # Vektor numerisch
alter                                         # Ausgabe
truefalse <- rep(c(TRUE, FALSE),10)           # Vektor logisch L√§nge 20
truefalse                                     # Ausgabe
alter[truefalse]                              # Ausgabe wo TRUE
```

### 3.2 Selektive Operationen inkl. der Funktion is.na()

Die Funktion is.na() gibt f√ºr den in Klammern stehenden Parameter (Vektor) TRUE zur√ºck, wenn das Element NICHT NA (NA = not available = fehlender Wert) ist und FALSE, wenn das Element NA ist. Die Funktion liefert als Ergebnis einen Vektor in der gleichen L√§nge wie der Parametervektor und zeigt f√ºr jedes Element die Position (Index) mit TRUE an, wo in einem Vektor NA steht. Sie dient dazu NA-Werte und deren Position zu identifizieren. Um z.B. alle Werte des Vektors alter anzuzeigen, die nicht NA sind, kann man die Funktion alter[!is.na(alter)] verwenden. Zur Erinnerung: Das ! bedeutet die Verneinung einer logischen Bedingung.
Wenn man aus diesem Vektor nur die Elemente angezeigt bekommen m√∂chte, die ein Alter zwischen 5 und 15 Jahren haben, kann man in eckigen Klammern hinter dem Vektornamen die logische Bedingung angeben, z.B. alter[!is.na(alter) & alter>= 5 & alter<= 15].

Um zuk√ºnftige Analysen nur auf die Elemente zu beschr√§nken, die nicht NA sind, kann man mit der Funktion alter2 <- alter[!is.na(alter)] einen neuen Vektor alter2 erstellen. Dann l√§sst sich anschlie√üend die Anzeige der Personen mit Alter zwischen 5 und 15 Jahren mit der Funktion alter2[alter2>=5 & alter2<=15] erreichen. Die Erwachsenen aus dieser Gruppe lassen sich mit der Anweisung alter2[alter2 > 17] anzeigen.

```{r 3_2, exercise=FALSE}
alter <- sample(c(floor(runif(16,min=0,max=100)),rep(NA,4))) # Vektor numerisch
alter                                         # Ausgabe
is.na(alter)                                  # Ausgabe logisch L√§nge 20 
alter[is.na(alter)]                           # Ausgabe wo TRUE
alter[!is.na(alter)]                          # Ausgabe wo FALSE
alter2 <- alter[!is.na(alter)]                # Vektor wo FALSE
alter2                                        # Anzeige
alter[!is.na(alter) & alter>=5 & alter<=15]   # Ausgabe wo FALSE & >=5 & <=15
alter2[alter2>=5 & alter2<=15]                # Ausgabe wo FALSE & >=5 & <=15
alter2[alter2 > 17]                           # Ausgabe wo FALSE & >17
```

### 3.3 √úbung

```{r 3_3-setup, exercise.setup="3_3", exercise=FALSE, echo=FALSE, include=FALSE}
alter <- c(75, 67, NA, 50, NA, 99, 88, 81, 80, 57, 5) 
```

Der Vektor alter wurde durch die Anweisung alter <- c(75, 67, NA, 50, NA, 99, 88, 81, 80, 57, 5) angelegt. Erstellen Sie eine selektive Operation auf den Vektor alter, welche nur die Werte anzeigt, die NA sind. Erstellen Sie eine zweite Operation, welche nur die Werte anzeigt, die nicht NA sind. Erstellen Sie eine dritte Operation, die unter den vorhandenen Werten nur die Werte anzeigt, deren Wert gr√∂√üer als 50 ist.

Die Anzeige sollte hinterher wie folgt aussehen: ![SelektiveOperation](images/selektiveoperation.jpg)

```{r 3_3, exercise=TRUE}

```

```{r 3_3-hint-1}
alter[is.na(alter)]
```
```{r 3_3-hint-2}
alter[!is.na(alter)]
```
```{r 3_3-hint-3}
alter[alter>50 & !is.na(alter)]
```

## 4. Textoperationen

Mit Variablen vom Typ character lassen sich viele Funktionen ausf√ºhren, u.a. erlaubt die Funktion paste() mehrere einzelne W√∂rter zu verbinden. Mit der Anweisung satz <- paste("Ich", "teste", "die", "paste()-Funktion") wird eine neue Variable mit dem Namen satz angelegt.

### 4.1 Funktion paste(), str_detect(), str_locate(), str_extract(), str_replace() und str_count()

Sie k√∂nnen mit der Funktion paste() auch Kombinationen von Zeichenketten erzeugen, wenn das Ergebnis aus mehrere Elementen verschiedenen Typs besteht, z.B. namen <- paste("Name",3:7,collapse=", ",sep="-"). Der Parameter collapse gibt an, wie die neu erzeugten Zeichenketten voneinander getrennt werden sollen und der Parameter sep gibt an, wenn anstatt eines Leerzeichens ein anderes Zeichen zur Trennung verwendet werden soll, um den ersten Parameter (hier: Name) und den zweiten Parameter (hier: 3 bis 7) zu verbinden. 

```{r 4_1, exercise=FALSE}
satz <- paste("Ich","teste","die","paste()-Funktion.") # Vektor character(L√§nge 1)
satz                                                   # Ausgabe
str(satz)                                              # Ausgabe mit Typ und L√§nge
namen <- paste("Name",3:7,collapse=", ",sep="-")       # Vektor character(L√§nge 1)
namen                                                  # Ausgabe
str(namen)                                             # Ausgabe mit Typ und L√§nge
```

Weitere Funktionen f√ºr die Textanalyse sind die Funktionen str_detect() zur Erkennung von Zeichenketten in einer Textvariablen, str_locate() zur Erkennung der Position, an welcher sich eine Zeichenkette in einer Textvariablen befindet, die Funktion str_extract() und str_extract_all(), um Zeichenketten eines spezifischen Formats aus einer Textvariablen zu extrahieren. Die Funktion str_replace_all() ersetzt eine Zeichenfolge in einer Textvariablen durch eine andere Zeichenkette.

Eine weitere wertvolle Funktion ist die Funktion str_count(), welche die Anzahl der Worte z√§hlt, wenn der Parameter boundary("word") verwendet wird. Im Folgenden wird dies am Beispiel der Analyse eines Tweets vorgestellt.

```{r 4_2, exercise=FALSE}
tweet<-"Trotz #Corona-Beschr√§nkungen sind f√ºr den morgigen #1Mai zahlreiche rechte \n                und/oder verachw√∂rungsideologische Demos in #Sachsen geplant. Ein √úbersichtsthread\n                mit den Top10 von @johannesgrunert: https://t.co/POtZkJRpJQ"
str_detect(tweet, "[:digit:]")                # Frage, ob Ziffer enthalten ist
str_locate(tweet, "[:digit:]")                # Frage, an welcher Position Ziffer
str_extract(tweet, "[:digit:]")               # Ziffer extrahieren
str_extract_all(tweet, "[:digit:]")           # Ziffern extrahieren
str_extract_all(tweet, "[:digit:]{2}")        # Ziffern extrahieren mit L√§nge 2
hashtag<-str_extract_all(tweet, "#[:alnum:]+")# Hashtags # mit nachfolgenden alpha
hashtags<-unlist(hashtag)                     # Hashtags in einfachen Vektor
hashtags<-as_tibble(table(hashtags))          # Hashtags in Tibble
hashtags
str_extract_all(tweet, "@[:alnum:]+")         # User @ mit nachfolgenden alpha
str_extract_all(tweet, "https?://[:graph:]+") # URLs extrahieren
str_count(tweet, boundary("word"))            # Anzahl Tokens (W√∂rter) z√§hlen 
str_extract_all(tweet, "[:alpha:]+")          # Alle Tokens mit wenigstens einem Buchstaben
str_replace_all(tweet, "[^[:alpha:]+]", "")   # Alle Leerzeichen entfernen
```

### 4.2 √úbung

```{r 4_3-setup, exercise.setup="4_3", exercise=FALSE, echo=FALSE, include=FALSE}
text<-"R ist einfach eine beliebte Programmiersprache und daher lerne ich diese Programmiersprache auch besonders gerne. Mehr Details unter https://cran.r-project.org/index.html"
```

Der Vektor text enth√§lt folgenden Inhalt: "R ist einfach eine beliebte Programmiersprache und daher lerne ich diese Programmiersprache auch besonders gerne. Mehr Details unter https://cran.r-project.org/index.html". 

Z√§hlen Sie, wie h√§ufig das Wort "Programmiersprache" und das Wort "ist" im Vektor vorkommt. Verwenden Sie anschlie√üend auch eine Funktion, um alle URLs in dem Vektor anzuzeigen.

Die Anzeige sollte hinterher wie folgt aussehen: ![TextOperation](images/textoperation.jpg)

```{r 4_3, exercise=TRUE}

```

```{r 4_3-hint-1}
str_count(text, c("Programmiersprache","ist"))  # Anzahl des Vorkommens z√§hlen 
```
```{r 4_3-hint-2}
str_extract_all(text, "https?://[:graph:]+")    # URLs extrahieren
```

## 5. Datumsoperationen

Das Datumsformat unterscheidet sich je Region und auch die Zeitzone variiert regional. Mit der Funktion Sys.getlocale(‚ÄúLC_ALL‚Äú) kann man sich die Systemeinstellungen anzeigen lassen und mit Sys.setlocale(‚ÄúLC_TIME‚Äú) die Region festlegen. Die Zeitzone l√§sst sich mit der Funktion Sys.timezone() abfragen. 

```{r 5_1, exercise=FALSE}
Sys.getlocale("LC_ALL")                       # Systemeinstellungen ALL anzeigen
Sys.setlocale("LC_TIME", "C")                 # Windows Betriebssystem, Zeit=US
Sys.setlocale("LC_TIME", "German")            # Windows Betriebssystem, Zeit=D
Sys.getlocale("LC_TIME")                      # Systemeinstellungen TIME anzeigen
Sys.timezone()                                # Aktuelle Zeitzone
```

### 5.1 Einfache Datumsoperationen

Es gibt spezielle Funktionen, die auf Datumsvariablen anwendbar sind. Der Datentyp der Datumsvariablen ist Date und der von Zeitvariablen ist POSIXct und POSIXlt. Alle Zeitinformationen werden als die Zeit in Tagen, Stunden oder Sekunden gespeichert, die seit dem 1.1.1970 vergangen ist. F√ºr Zeiten vor diesem Datum gibt eine negative Zahl die Tage bzw. Sekunden bis zum 1.1.1970 an. 

Die Funktion Sys.Date() kann verwendet werden, um das aktuelle Datum anzuzeigen und die Funktion Sys.time(), um die aktuelle Zeit und das aktuelle Datum anzuzeigen. Mit der Anweisung unclass(Sys.Date()) bzw. unclass(Sys.time()) wird Ihnen die interne Darstellung des aktuellen Datums bzw. der aktuellen Zeit angezeigt und dies ist die Zahl der Tage bzw. Sekunden, die seit dem 1.1.1970 vergangen sind.

```{r 5_2, exercise=FALSE}
heute <- Sys.Date()                           # Aktuelles Datum
heute                                         # Anzeige
str(heute)                                    # Anzeige Typ
zeit <- Sys.time()                            # Aktuelle Zeit
zeit                                          # Anzeige
str(zeit)                                     # Anzeige Typ
unclass.heute <- unclass(heute)               # Tage seit dem 1.1.1970
unclass.heute                                 # Anzeige
str(unclass.heute)                            # Anzeige Typ
unclass.zeit <- unclass(zeit)                 # Sekunden seit dem 1.1.1970
unclass.zeit                                  # Anzeige
str(unclass.zeit)                             # Anzeige Typ
```

### 5.2 Datumsoperationen f√ºr Datentyp Date

M√∂chte man sich den Wochentag eines Datums anzeigen lassen, so geht dies mit der Funktion weekdays(). Die Anzeige des Monats kann mit der Funktion months() erreicht werden. Eine umfassendere M√∂glichkeit ist jedoch die Konvertierung von Datum und Uhrzeit in das Format POSIXlt mit der Funktion as.POSIXlt(). Wenn man das Ergebnis anschlie√üend mit der Funktion unclass() konvertiert, so kann man auf die Variablen wday, mday, mon, year, zone, hour, min und sec zugreifen.

```{r 5_3, exercise=FALSE}
heute <- Sys.Date()                           # Aktuelles Datum
heute.konv <- as.POSIXlt(heute)               # Konvertiert in Typ POSIXlt
str(heute.konv)                               # Anzeige Typ
unclass.heute.konv <- unclass(heute.konv)     # Konvertiert mit unclass()                     
unclass.heute.konv                            # Anzeige
unclass.heute.konv$wday                       # Wochentag
unclass.heute.konv$mday                       # Tag im Monat
1+unclass.heute.konv$mon                      # Monat (mon vorbei + 1)
1900 + unclass.heute.konv$year                # Jahr  (year + 1900)
weekdays(heute)                               # Wochentag
months(heute)                                 # Monat
```

### 5.3 Datumsoperationen f√ºr Datentyp POSIXct

Datumsoperationen f√ºr Datum und Zeit.

```{r 5_4, exercise=FALSE}
zeit <- Sys.time()                            # Aktuelle Zeit
zeit.konv <- as.POSIXlt(zeit)                 # Konvertiert in Typ POSIXlt 
str(zeit.konv)                                # Anzeige Typ
unclass.zeit.konv <- unclass(zeit.konv)       # Konvertiert mit unclass()                     
unclass.zeit.konv                             # Anzeige
unclass.zeit.konv$wday                        # Wochentag
unclass.zeit.konv$mday                        # Tag im Monat
1+unclass.zeit.konv$mon                       # Monat (mon vorbei + 1)
1900 + unclass.zeit.konv$year                 # Jahr  (year + 1900)
unclass.zeit.konv$zone                        # Zeitzone CET=Central European Time
unclass.zeit.konv$hour                        # Stunde
unclass.zeit.konv$min                         # Minute
unclass.zeit.konv$sec                         # Sekunde
weekdays(zeit)                                # Wochentag
months(zeit)                                  # Monat
```

### 5.4 N√ºtzliche Konvertierungen

Manchmal gilt es auch einen Text in eine Variable vom Typ POSIXlt zu konvertieren. Die Funktion strptime() unterst√ºtzt dies, z.B. strptime("M√§rz 09, 1964 14:23","%B %d, %Y %H:%M").

Die geschickteste Art, die Details zu Datum und Uhrzeit zu erhalten, ist jedoch, nachdem man eine Variable mit der Funktion as.POSIXct() in das POSIXct-Format konvertiert hat und anschlie√üend die Funktion format() verwendet, um sich Tag, Monat, Jahr, Stunde, Minute und Sekunde anzeigen zu lassen, z.B. mit der Anweisung format(Variable, format="%d.%m.%Y, %H:%M:%S").

```{r 5_5, exercise=FALSE}
a <- strptime("M√§rz 09, 1964 14:23","%B %d, %Y %H:%M") # Konvertiert Text in Zeit
a                                             # Anzeige CET=Central European Time
str(a)                                        # Anzeige Typ
b <- as.POSIXct("2020-03-09 11:12:54")        # Konvertiert Text in Zeit
b                                             # Anzeige CET=Central European Time
str(b)                                        # Anzeige Typ
format(b, format="%d")                        # Tag
format(b, format="%m")                        # Monat
format(b, format="%Y")                        # Jahr
format(b, format="%H")                        # Stunde
format(b, format="%M")                        # Minute
format(b, format="%S")                        # Sekunde
format(b, format="%d.%m.%Y, %H:%M:%S")        # Tag, Monat, Jahr, Stunde, Min, Sek
c <- as.POSIXct("11.04.2019, 14:52:31", format="%d.%m.%Y, %H:%M:%S") #Konv T->Zeit
format(c, format="%d")                        # Tag
format(c, format="%m")                        # Monat
format(c, format="%Y")                        # Jahr
format(c, format="%H")                        # Stunde
format(c, format="%M")                        # Minute
format(c, format="%S")                        # Sekunde
format(c, format="%d.%m.%Y, %H:%M:%S")        # Tag, Monat, Jahr, Stunde, Min, Sek
```

### 5.5 Vergleiche, Addition, Subtraktion und die Berechnung von Differenzen

Es gibt auch n√ºtzliche Berechnungsfunktionen (+, -) und Vergleiche, die mit Datums- und Zeitvariablen arbeiten. Die Funktion difftime(Zeit-1, Zeit-2, units = 'secs') gestattet die Differenz der Zeitvariablen Zeit-1 und Zeit-2 zu ermitteln. √úber den Parameter units kann angegeben werden, in welcher Einheit die Differenz berechnet werden soll (Wochen=weeks, Tage=days, Stunden=hours, Minuten=mins, Sekunden=secs).

Das Paket lubridate erlaubt viele weitere essenzielle Operationen mit Datums- und Zeitvariablen. 

```{r 5_6-setup, exercise.setup="5_6", exercise=FALSE, echo=FALSE, include=FALSE}
heute <- Sys.Date()                           # Aktuelles Datum
```

```{r 5_6, exercise=TRUE}
heute                                         # Ausgabe
weekdays(heute)                               # Wochentag
√ºbermorgen <- heute+2                         # Datumsberechnung mit +
√ºbermorgen                                    # Ausgabe
weekdays(√ºbermorgen)                          # Wochentag
vorgestern <- heute-2                         # Datumsberechnung mit - 
vorgestern                                    # Ausgabe
weekdays(vorgestern)                          # Wochentag
√ºbermorgen - vorgestern                       # Berechnung Zeitdifferenz in Tagen
d <- as.POSIXct("11.04.2021, 14:52:31", format="%d.%m.%Y, %H:%M:%S") #Konv T->Zeit
d                                             # Ausgabe
e <- as.POSIXct("11.04.2021, 15:54:31", format="%d.%m.%Y, %H:%M:%S") #Konv T->Zeit
e                                             # Ausgabe
difftime(e,d,units="weeks")                   # Zeitdifferenz in Wochen
difftime(e,d,units="days")                    # Zeitdifferenz in Tagen
difftime(e,d,units="hours")                   # Zeitdifferenz in Stunden
difftime(e,d,units="mins")                    # Zeitdifferenz in Minuten
difftime(e,d,units="secs")                    # Zeitdifferenz in Sekunden
```

### 5.6 √úbung

```{r 5_7-setup, exercise.setup="5_7", exercise=FALSE, echo=FALSE, include=FALSE}
heute <- Sys.Date()                           # Aktuelles Datum
```

Geben Sie die Variable heute und den Wochentag von heute aus. Geben Sie anschlie√üend auch den Wochentag von morgen aus, wenn in der Variablen heute das aktuelle Datum steht.
Berechnen Sie die in einem weiteren Schritt die Anzahl der Tage bis zum kommenden Heiligen Abend, dem 24. Dezember diesen Jahres.

Die Anzeige sollte hinterher √§hnlich wie folgt aussehen, wobei der Wochentag und die Anzahl der Tage bis Heiligabend davon abh√§ngt, an welchem Tag Sie diese √úbung ausf√ºhren: ![DatumsOperation](images/datumsoperation.jpg)

```{r 5_7, exercise=TRUE}

```

```{r 5_7-hint-1}
heute
weekdays(heute)                                # Wochentag heute
weekdays(heute+1)                              # Wochentag morgen
```
```{r 5_7-hint-2}
heute.konv<-as.POSIXlt(heute)                  # Datumsformat konvertieren
heute.unclass<-unclass(heute.konv)             # Unclass
heute.jahr<-heute.unclass$year+1900            # Jahr aktuell
heute.jahr
heiligabend<-paste(heute.jahr,"-12-24",sep="") # Datum von Heilig Abend
heiligabend
difftime(heiligabend,heute,units="days")       # Differenz in Tagen
```

## 6. Tabellenjoins

Oft besteht das Interesse Daten f√ºr eine Analyse miteinander zu verbinden, wenn nicht alle relevanten Informationen in einer Tabelle vorliegen bzw. sogar bewusst entsprechend dem Entity-Relationship-Modell f√ºr eine effektivere, redundanzfreie Datentr√§gernutzung normalisiert in unterschiedlichen Datenbanktabellen abgelegt sind. 

F√ºr diesen Zweck kann man Tabellen x und y mit der Funktion merge() zusammenf√ºhren. Die Parameter by.x und by.y geben die Spaltennamen an, √ºber welche der Join erfolgen soll. Das Ergebnis ist eine Tabelle, welche die Inhalte der Tabelle x und die Inhalte der Tabelle y zusammenf√ºhrt, wenn f√ºr den Schl√ºssel, der mit by.x angegeben wurde, ein identischer Eintrag mit dem Schl√ºssel by.y in der Tabelle y existiert. Wenn der Parameter all.x=TRUE verwendet wird und kein Eintrag f√ºr den Schl√ºssel by.x in by.y existiert, dann werden die sonst mit den Werten der Tabelle y bef√ºllten Spalten mit NA gef√ºllt (Outer Join, Partial Match). Wird der Parameter all.x=TRUE nicht verwendet und es existiert kein Eintrag f√ºr den Schl√ºssel by.x in by.y, so wird der Datensatz mit by.x nicht in die Ergebnistabelle aufgenommen (Inner Join, Full Match).

![Tabellenjoin](images/join.jpg)

### 6.1 Join von Tabellen

Nachfolgend werden die Tabellen (Dataframes) regisseur und film gejoint.

```{r 6_1, exercise=FALSE}
regisseur <- data.frame(                      # Regisseure
    name = c("Spielberg","Scorsese","Hitchcock","Schl√∂ndorff","Polanski"),
    nationalit√§t = c("USA","USA","GB","Deutschland","Polen"),
    stringsAsFactors=FALSE)
film <- data.frame(                           # Filme
    nachname = c("Spielberg","Scorsese","Hitchcock","Hitchcock",
           	"Spielberg","Schl√∂ndorff","Polanski"),
    titel = c("Der Wei√üe Hai","The Irishman","Psycho","Die V√∂gel",
    		    "Catch Me If You Can","Die Blechtrommel","Chinatown"),
    stringsAsFactors=FALSE)
m1 <- merge(regisseur,film,                   # Inner Join
            by.x="name",by.y="nachname")
m1                                            # ->Join Regisseur mit Film
dim(m1)
regisseur.neu <-  c("deJenlis","Frankreich")  # Neuer Regisseur
regisseur <- rbind(regisseur,regisseur.neu)
m2 <- merge(regisseur,film,                   # Inner Join
            by.x="name",by.y="nachname")
m2                                            # ->Keine Zeile f√ºr neuen Regisseur
dim(m2)
m3 <- merge(regisseur,film,                   # Outer Join
            by.x="name",by.y="nachname",
            all.x = TRUE)
m3                                            # ->Extra Zeile Regisseur ohne Film
dim(m3)                                            
regisseur.neu <-  c("Polanski","Frankreich")  # Neuer Regisseur - Name doppelt
regisseur <- rbind(regisseur,regisseur.neu)
m4 <- merge(regisseur,film,                   # Inner Join
            by.x="name",by.y="nachname")
m4                                            # ->Zwei Zeilen Polanski-Film
dim(m4)
m5 <- merge(regisseur,film,                   # Outer Join
            by.x="name",by.y="nachname",
            all.x = TRUE)
m5                                            # ->Extra Zeile Regisseur ohne Film
dim(m5)
```

### 6.2 √úbung

```{r 6_2-setup, exercise.setup="6_2", exercise=FALSE, echo=FALSE, include=FALSE}
airlines <- data.frame(                      # Fluggesellschaften
    carrier = c("LH","DL","US","AF","FR"),
    name = c("Lufthansa","Delta Airlines","US Airlines","Air France","Ryan Air"),
    stringsAsFactors=FALSE)
flights <- data.frame(                       # Fl√ºge
    carrier = c("LH","AF","LH","FR","DL","LH","AF","FR"),
    number  = c("130","98","12","8854","64","78","999","2"),
    dest    = c("Munich","Paris","Ansbach","Faro","Atlanta","Cancun","Phuket","Bremen"),
    stringsAsFactors=FALSE)
```

Lassen Sie sich zun√§chst die Inhalte der Dataframes airlines und flights anzeigen.

```{r 6_2, exercise=TRUE}
airlines
flights
```

```{r 6_3-setup, exercise.setup="6_3", exercise=FALSE, echo=FALSE, include=FALSE}
airlines <- data.frame(                      # Fluggesellschaften
    carrier = c("LH","DL","US","AF","FR"),
    name = c("Lufthansa","Delta Airlines","US Airlines","Air France","Ryan Air"),
    stringsAsFactors=FALSE)
flights <- data.frame(                       # Fl√ºge
    carrier = c("LH","AF","LH","FR","DL","LH","AF","FR"),
    number  = c("130","98","12","8854","64","78","999","2"),
    dest    = c("Munich","Paris","Ansbach","Faro","Atlanta","Cancun","Phuket","Bremen"),
    stringsAsFactors=FALSE)
```

F√ºhren Sie zuerst einen Inner Join und anschlie√üend einen Outer Join √ºber die beiden Tabellen (Dataframes) airlines und flights aus, wobei diese √ºber die Schl√ºsselfelder carrier verkn√ºpft werden und speichern das Ergebnis in dem Dataframe flug ab. Geben Sie jeweils anschlie√üend die Inhalte des Dataframe flug aus.

Die Anzeige sollte hinterher wie folgt aussehen: ![Join](images/tablejoin.jpg)

```{r 6_3, exercise=TRUE}

```

```{r 6_3-hint-1}
flug <- merge(airlines,flights,                # Inner Join
            by.x="carrier",by.y="carrier")
flug
```
```{r 6_3-hint-2}
flug <- merge(airlines,flights,                # Outer Join
            by.x="carrier",by.y="carrier",
            all.x = TRUE)
flug
```

## 7. Quiz

```{r 7_1, echo = FALSE}
quiz(
  question("Welche der folgenden Aussagen sind korrekt?", allow_retry = TRUE, random_answer_order = TRUE,
    answer("Die Funktion round(b,2) rundet den Inhalt der numerischen Variable b auf zwei Nachkommastellen.", correct = TRUE),
    answer("Wenn R zwei Vektoren mit unterschiedlicher L√§nge bei arithmetischen Operationen verwendet, werden die jeweiligen Operationen (`+`, `-`, `*`, etc.) Element f√ºr Element abgearbeitet, wobei der k√ºrzere Vektor so lange wiederverwendet wird, bis alle Berechnungen geleistet wurden.", correct = TRUE),
    type = "multiple"
  ),
  question("Welche der folgenden Aussagen sind korrekt?", allow_retry = TRUE, random_answer_order = TRUE,
    answer("Das Symbol f√ºr die logische NEGATION in R ist das Ausrufungszeichen '!'.", correct = TRUE),
    answer("Wenn die Anweisung a <- c('250') ausgef√ºhrt wurde, dann liefert die Anweisung is.numeric(a) & a > 84 das Ergebnis TRUE", message = "Nein, TRUE ist nicht korrekt, da a eine Character-Variable (nicht numerisch wegen der Anf√ºhrungszeichen) ist und damit die Funktion is.numeric(a) ein FALSE zur√ºckgibt."),
    answer("Die Anweisung liste <- a[!is.na(a)] selektiert nur die Werte aus dem Vektor a, welche NA sind, und speichert diese in dem Vektor liste ab.", message = "Nein, das Ausrufungszeichen vor dem is.na gibt an, dass nur die Werte, welche NICHT NA sind in dem Vektor a in dem Vektor liste gespeichert werden."),
    type = "multiple"
  ),
  question("Welche der folgenden Aussagen sind korrekt?", allow_retry = TRUE, random_answer_order = TRUE,
    answer('namen <- paste("Raum",4:6,collapse=", ",sep="-") speichert die folgenden drei Zeichenketten in dem Vektor namen ab: "Raum-4", "Raum-5", "Raum-6".', correct = TRUE),
    answer("sys.date() gibt das aktuelle Datum aus.", message = "Nein, Sys.Date() leistet dies. Gro√ü- und Kleinschreibung wird in R unterschieden."),
    answer("Die Funktion merge() erlaubt Dataframes miteinander zu joinen, wobei die Parameter by.x und by.y die Namen der Spalten angeben, √ºber deren Inhalte (Schl√ºssel) die Verkn√ºpfung erfolgem soll", correct = TRUE),
    type = "multiple"
  )
)
```

## Ende 

Gratulation!

Sie haben dieses Tutorial erfolgreich ausgef√ºhrt und einen Einblick in wesentliche Operationen der Programmiersprache R erhalten.